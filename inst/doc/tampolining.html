<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Trampolining in R</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Trampolining in R</h1>



<p>This package and this vignette are heavily inspired by the <code>trampoline</code> package in Python (<a href="https://gitlab.com/ferreum/trampoline" class="uri">https://gitlab.com/ferreum/trampoline</a>). In fact, this package is more or less a straight port of that package to R, and this vignette uses all the same examples from the Python <code>trampoline</code> readme, so I thought I would acknowledge that first. For more interesting discussion on trampolining, what it is, what it is good for, etc. please read this <a href="https://tailrecursion.com/wondr/posts/tail-recursion-in-r.html">post</a> by Alan Dipert for discussion specific to R, and this more general <a href="https://eli.thegreenplace.net/2017/on-recursion-continuations-and-trampolines/">post</a> by Eli Bendersky that also goes into a number of related programming concepts and is a really interesting read (though it is focused on Python and Clojure).</p>
<div id="what-is-trampolining" class="section level1">
<h1>What is Trampolining?</h1>
<p>In brief, trampolining is a method of doing recursive programming that let’s you theoretically recurse infinitely. Why can’t you do this normally? Well, languages that allow recursive programming, that is, functions that can call themselves, such as R, usually have what is called a ‘call stack’. A call stack keeps tracks of which calls must be resolved before other calls can be executed. In a deeply recursive function, this call stack gets very large, and most programming languages have a limit to how large it can get, including R. We can demonstrate this by creating a very simple recursive function and then running it very deeply.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>print_numbers &lt;-<span class="st"> </span><span class="cf">function</span>(n) {</span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="cf">if</span>(n <span class="op">&gt;=</span><span class="st"> </span><span class="dv">1</span>) {</span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="kw">print_numbers</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)</span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="kw">print</span>(n)</span>
<span id="cb1-5"><a href="#cb1-5"></a>  }</span>
<span id="cb1-6"><a href="#cb1-6"></a>}</span></code></pre></div>
<p>This trivial function prints numbers from 1 to <code>n</code> by calling itself to print the previous number. The numbers are printed in correct order because the function recurses all the way until <code>n</code> is less than one before continuing, then each recursive call returns to the previous call in reverse order. Let’s try it.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">print_numbers</span>(<span class="dv">5</span>)</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">#&gt; [1] 1</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">#&gt; [1] 2</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">#&gt; [1] 3</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">#&gt; [1] 4</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="co">#&gt; [1] 5</span></span></code></pre></div>
<p>Now, if we increase <code>n</code> to a very large number, we can easily ‘blow up’ the call stack.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">print_numbers</span>(<span class="dv">10000</span>)</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co">#&gt; Error: evaluation nested too deeply: infinite recursion / options(expressions=)?</span></span></code></pre></div>
<p>Trampolining is a way to get around this limit by avoiding using the call stack. The <code>trampoline</code> package implements a simple general trick that theoretically works on any recursive algorithm, which takes advantage of ‘generator’ functions. Now, this didn’t use to be possible in R, because R does not have a native ‘generator’ concept. However, R now does have ‘generators’, thanks to the <code>{coro}</code> package. You don’t actually need to know anything about ‘generators’ to use <code>trampoline</code>, however, if you are curious and would like to know more, the <a href="https://github.com/r-lib/coro">documentation</a> of <code>{coro}</code> provides an excellent introduction. Here is the <code>trampoline</code> version of the <code>print_numbers()</code> example. Instead of a function, we create a generator (using <code>coro::generator()</code>), and then we wrap any recursive calls with the <code>yield()</code> function (this causes the generator to return the argument to <code>yield()</code> to the calling function and pause execution, which drives the recursion). In practice, all we need to remember is to add <code>yield()</code> around our recursive calls. This is the <code>trampoline</code> version:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">library</span>(trampoline)</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co">## generator version</span></span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a>print_numbers &lt;-<span class="st"> </span>coro<span class="op">::</span><span class="kw">generator</span>(<span class="cf">function</span>(n) {</span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="cf">if</span>(n <span class="op">&gt;=</span><span class="st"> </span><span class="dv">1</span>) {</span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="kw">yield</span>(<span class="kw">print_numbers</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>))</span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="kw">print</span>(n)</span>
<span id="cb4-8"><a href="#cb4-8"></a>  }</span>
<span id="cb4-9"><a href="#cb4-9"></a>})</span>
<span id="cb4-10"><a href="#cb4-10"></a></span>
<span id="cb4-11"><a href="#cb4-11"></a>catch &lt;-<span class="st"> </span><span class="kw">capture.output</span>(<span class="kw">trampoline</span>(<span class="kw">print_numbers</span>(<span class="dv">10000</span>))) <span class="co">## capture output to prevent flooding document with numbers</span></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="kw">head</span>(catch)</span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="co">#&gt; [1] &quot;[1] 1&quot; &quot;[1] 2&quot; &quot;[1] 3&quot; &quot;[1] 4&quot; &quot;[1] 5&quot; &quot;[1] 6&quot;</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="kw">tail</span>(catch)</span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="co">#&gt; [1] &quot;[1] 9995&quot;  &quot;[1] 9996&quot;  &quot;[1] 9997&quot;  &quot;[1] 9998&quot;  &quot;[1] 9999&quot;  &quot;[1] 10000&quot;</span></span></code></pre></div>
<p>Note that you don’t have to call <code>coro::generator()</code> yourself. If you pass a plain function to <code>trampoline()</code> it will convert it to a generator for you. This works too:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>print_numbers &lt;-<span class="st"> </span><span class="cf">function</span>(n) {</span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="cf">if</span>(n <span class="op">&gt;=</span><span class="st"> </span><span class="dv">1</span>) {</span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="kw">yield</span>(<span class="kw">print_numbers</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>))</span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="kw">print</span>(n)</span>
<span id="cb5-5"><a href="#cb5-5"></a>  }</span>
<span id="cb5-6"><a href="#cb5-6"></a>}</span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="kw">trampoline</span>(<span class="kw">print_numbers</span>(<span class="dv">5</span>))</span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="co">#&gt; [1] 1</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="co">#&gt; [1] 2</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co">#&gt; [1] 3</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="co">#&gt; [1] 4</span></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="co">#&gt; [1] 5</span></span></code></pre></div>
<p>Note also that, as seen at the beginning of the readme, you can pass your recursive functions as named arguments to <code>trampoline()</code>, which allows you to define to function within your <code>trampoline()</code> call if you wish. You will find an example of this at the end of this vignette too.</p>
<p><code>trampoline</code> also works with recursive function that return a value at the end. To return a final value you just need to wrap the return value with the <code>trm_return()</code> function. This flags to <code>trampoline</code> that this should be returned from the final recursion of the function. Here is an example of a recursive function to calculate and return a factorial:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>factorial &lt;-<span class="st"> </span><span class="cf">function</span>(n) {</span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="cf">if</span>(n <span class="op">&lt;=</span><span class="st"> </span><span class="dv">1</span>) {</span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="kw">return</span>(<span class="dv">1</span>)</span>
<span id="cb6-4"><a href="#cb6-4"></a>  }</span>
<span id="cb6-5"><a href="#cb6-5"></a>  val &lt;-<span class="st"> </span><span class="kw">factorial</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)</span>
<span id="cb6-6"><a href="#cb6-6"></a>  <span class="kw">return</span>(val <span class="op">*</span><span class="st"> </span>n)</span>
<span id="cb6-7"><a href="#cb6-7"></a>}</span></code></pre></div>
<p>Running this function will exhaust the call stack in as little as 5000 recursions:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">factorial</span>(<span class="dv">5000</span>)</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co">#&gt; Error: evaluation nested too deeply: infinite recursion / options(expressions=)?</span></span></code></pre></div>
<p>The <code>trampoline()</code> version runs fine, and shows us that the factorial of 5000 is far too large to be represented as an integer in R (resulting in <code>Inf</code>).</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>factorial1 &lt;-<span class="st"> </span><span class="cf">function</span>(n) {</span>
<span id="cb8-2"><a href="#cb8-2"></a>  <span class="cf">if</span>(n <span class="op">&lt;=</span><span class="st"> </span><span class="dv">1</span>) {</span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="kw">return</span>(<span class="kw">trm_return</span>(<span class="dv">1</span>))</span>
<span id="cb8-4"><a href="#cb8-4"></a>  }</span>
<span id="cb8-5"><a href="#cb8-5"></a>  val &lt;-<span class="st"> </span><span class="kw">yield</span>(<span class="kw">factorial1</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>))</span>
<span id="cb8-6"><a href="#cb8-6"></a>  <span class="kw">return</span>(val <span class="op">*</span><span class="st"> </span>n)</span>
<span id="cb8-7"><a href="#cb8-7"></a>}</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="kw">trampoline</span>(<span class="kw">factorial1</span>(<span class="dv">5000</span>))</span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="co">#&gt; [1] Inf</span></span></code></pre></div>
<p>With the standard <code>trampoline</code> approach, generator functions spawn generator functions, and each generator is stored in a list internally. All must exist simultaneously, which means that memory can be exhausted in very deep recursions (but typically we have much more RAM available than what is provided in the call stack – in case you are wondering why the call stack is so limited, <a href="https://softwareengineering.stackexchange.com/questions/330626/why-does-the-call-stack-have-a-static-maximum-size">here</a> is one stackexchange question related to that). This approach is very flexible and allows pretty much arbitrary recursive functions where all we have to do is wrap our recursive call in <code>yield()</code>, which makes our function a generator. However, in some cases our recursive functions can be rewritten in a form that allows for a more memory efficient approach. These are know as tail call recursions – their important characteristic is that the recursive call comes as the very last operation in the function. If so, this makes the function a type of simple continuation which can be easily transformed into a standard loop under the hood. <code>trampoline</code> supports tail call recursion by providing a function <code>trm_tailcall()</code> that you can wrap your recursive call in, and which let’s <code>trampoline</code> know that it can take advantage of this more efficient form (additionally for tail call recursions we do not need to call <code>yield()</code> though it will not hurt to do so). For example, the above <code>factorial</code> recursion function is not a tail call recursion because the last operation is the multiplication by <code>n</code>, rather than the recursive call. However, this function can be transformed into a tail call recursion with the help of an additional argument:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>factorial2 &lt;-<span class="st"> </span><span class="cf">function</span>(n, <span class="dt">x =</span> <span class="dv">1</span>) {</span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span class="kw">force</span>(x) <span class="co">## necessary thanks to R&#39;s lazy evaluation</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="cf">if</span>(n <span class="op">&lt;=</span><span class="st"> </span><span class="dv">1</span>) {</span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="kw">return</span>(<span class="kw">trm_return</span>(x))</span>
<span id="cb9-5"><a href="#cb9-5"></a>  }</span>
<span id="cb9-6"><a href="#cb9-6"></a>  val &lt;-<span class="st"> </span><span class="kw">trm_tailcall</span>(<span class="kw">factorial2</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>, x <span class="op">*</span><span class="st"> </span>n))</span>
<span id="cb9-7"><a href="#cb9-7"></a>  <span class="kw">return</span>(val)</span>
<span id="cb9-8"><a href="#cb9-8"></a>}</span>
<span id="cb9-9"><a href="#cb9-9"></a></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="kw">trampoline</span>(<span class="kw">factorial2</span>(<span class="dv">5000</span>))</span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="co">#&gt; [1] Inf</span></span></code></pre></div>
<p>Note the use of <code>force(x)</code>. This is required to work around R’s default lazy evaluation, which means an argument is not evaluated until it is used. <code>force(x)</code> makes sure <code>x</code> is evaluated before it is passed to the next recursion. Without this, it would not be evaluated until the very end of the recursion sequence when it is returned. This has the side effect of requiring R to maintain a call stack to keep track of the environment where <code>x</code> was created, and this causes a stack overflow. If you get an error saying the call stack is exhausted when using <code>trampoline()</code>, lazy evaluation is usually the culprit. Experimenting with forcing different arguments will generally resolve it. To be safe you can simply force all arguments if you wish (note you do not have to use <code>force()</code>, you only have to use the argument somehow before it is passed to the next function – just putting <code>n; x</code> as the first line of the above function would work, though it is less clear what the purpose is, which is why <code>force()</code> exists).</p>
<p>Just to show that these all return the same result, we can run them with smaller <code>n</code> where the regular recursive version will work.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw">factorial</span>(<span class="dv">10</span>)</span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="co">#&gt; [1] 3628800</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="kw">trampoline</span>(<span class="kw">factorial1</span>(<span class="dv">10</span>))</span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="co">#&gt; [1] 3628800</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="kw">trampoline</span>(<span class="kw">factorial2</span>(<span class="dv">10</span>))</span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="co">#&gt; [1] 3628800</span></span></code></pre></div>
<p>The second version using the tail call should use much less memory than the no tail call version. We can see that using the <code>bench::mark()</code> function.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>bench_res &lt;-<span class="st"> </span>bench<span class="op">::</span><span class="kw">mark</span>(<span class="kw">trampoline</span>(<span class="kw">factorial1</span>(<span class="dv">1000</span>)), </span>
<span id="cb11-2"><a href="#cb11-2"></a>                         <span class="kw">trampoline</span>(<span class="kw">factorial2</span>(<span class="dv">1000</span>)), </span>
<span id="cb11-3"><a href="#cb11-3"></a>                         <span class="kw">trampoline</span>(<span class="kw">factorial1</span>(<span class="dv">2000</span>)), </span>
<span id="cb11-4"><a href="#cb11-4"></a>                         <span class="kw">trampoline</span>(<span class="kw">factorial2</span>(<span class="dv">2000</span>)), </span>
<span id="cb11-5"><a href="#cb11-5"></a>                         <span class="kw">trampoline</span>(<span class="kw">factorial1</span>(<span class="dv">5000</span>)), </span>
<span id="cb11-6"><a href="#cb11-6"></a>                         <span class="kw">trampoline</span>(<span class="kw">factorial2</span>(<span class="dv">5000</span>)),</span>
<span id="cb11-7"><a href="#cb11-7"></a>                         <span class="kw">trampoline</span>(<span class="kw">factorial1</span>(<span class="dv">10000</span>)), </span>
<span id="cb11-8"><a href="#cb11-8"></a>                         <span class="kw">trampoline</span>(<span class="kw">factorial2</span>(<span class="dv">10000</span>)),</span>
<span id="cb11-9"><a href="#cb11-9"></a>                         <span class="dt">check =</span> <span class="ot">FALSE</span>, <span class="dt">iterations =</span> <span class="dv">3</span>)</span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="co">#&gt; Warning: Some expressions had a GC in every iteration; so filtering is disabled.</span></span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="kw">plot</span>(<span class="kw">as.numeric</span>(bench_res<span class="op">$</span>mem_alloc)[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)] <span class="op">~</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">1000</span>, <span class="dv">2000</span>, <span class="dv">5000</span>, <span class="dv">10000</span>), <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, </span>
<span id="cb11-13"><a href="#cb11-13"></a>     <span class="dt">xlab =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;Bytes Allocated&quot;</span>)</span>
<span id="cb11-14"><a href="#cb11-14"></a><span class="kw">points</span>(<span class="kw">as.numeric</span>(bench_res<span class="op">$</span>mem_alloc)[<span class="kw">c</span>(<span class="ot">FALSE</span>, <span class="ot">TRUE</span>)] <span class="op">~</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">1000</span>, <span class="dv">2000</span>, <span class="dv">5000</span>, <span class="dv">10000</span>), <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>)</span>
<span id="cb11-15"><a href="#cb11-15"></a><span class="kw">legend</span>(<span class="st">&quot;right&quot;</span>, <span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">&quot;No Tail Call&quot;</span>, <span class="st">&quot;Tail Call&quot;</span>), <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;red&quot;</span>, <span class="st">&quot;blue&quot;</span>), <span class="dt">lty =</span> <span class="dv">1</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>We can also see that the tail call version is slightly faster:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">plot</span>(<span class="kw">as.numeric</span>(bench_res<span class="op">$</span>total_time)[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)] <span class="op">~</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">1000</span>, <span class="dv">2000</span>, <span class="dv">5000</span>, <span class="dv">10000</span>), <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, </span>
<span id="cb12-2"><a href="#cb12-2"></a>     <span class="dt">xlab =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;Total Time&quot;</span>)</span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="kw">points</span>(<span class="kw">as.numeric</span>(bench_res<span class="op">$</span>total_time)[<span class="kw">c</span>(<span class="ot">FALSE</span>, <span class="ot">TRUE</span>)] <span class="op">~</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">1000</span>, <span class="dv">2000</span>, <span class="dv">5000</span>, <span class="dv">10000</span>), <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>)</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="kw">legend</span>(<span class="st">&quot;right&quot;</span>, <span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">&quot;No Tail Call&quot;</span>, <span class="st">&quot;Tail Call&quot;</span>), <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;red&quot;</span>, <span class="st">&quot;blue&quot;</span>), <span class="dt">lty =</span> <span class="dv">1</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>Note that <code>trampoline</code> adds overhead that may result in a slower performance. However, the overhead is fairly small. It is noticeable for extremely fast computations like the ones done here, but for more complicated computations, the overhead should represent a small proportion of the total execution time. Another performance related note is that <code>trampoline()</code> internally disables R’s Just-In-Time (JIT) compilation (sometimes referred to as the ‘byte’ compiler). By default R will attempt to precompile functions before the first or second time they are called (depending on their ‘size’). Since generator functions are created anew in each recursion, and they are called twice overall, this mean each one will be precompiled by R, which adds enormous overhead, especially given we know they will not be called a third time in most cases. So disabling JIT makes <code>trampoline()</code> faster. On the other hand it means that any function you write that gets called for the first time inside the <code>trampoline()</code> call will not be compiled. In some cases this means you might not be able to take advantage of compilation for a function that could benefit from it. If so, you can get around this issue by calling your function once or twice before running <code>trampoline()</code> which will cause R to compile it (assuming you are using default JIT settings, accessible with the <code>compiler::enableJIT()</code> function). Alternatively you could explicitly precompile your function yourself using the <code>compiler::cmpfun()</code> function.</p>
<p>In this vignette we have used some very basic recursive functions to demonstrate how <code>trampoline</code> works, but it’s true power only becomes apparent in more complicated situations. If your recursion is simple enough to be converted to a tail call recursion, then existing methods might be enough for you (e.g. this <a href="https://tailrecursion.com/wondr/posts/tail-recursion-in-r.html">post</a> presents an R function by Jim Hester that allows tail call recursion). <code>trampoline</code> however, let’s you run pretty much any type of recursive function without having to think too much about it. For example, mutually recursive functions work out of the box, like this classic trivial example:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>even &lt;-<span class="st"> </span>coro<span class="op">::</span><span class="kw">generator</span>(<span class="cf">function</span>(n) {</span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="cf">if</span> (n <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) <span class="kw">trm_return</span>(<span class="ot">TRUE</span>) <span class="cf">else</span> <span class="kw">yield</span>(<span class="kw">odd</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>))</span>
<span id="cb13-3"><a href="#cb13-3"></a>})</span>
<span id="cb13-4"><a href="#cb13-4"></a></span>
<span id="cb13-5"><a href="#cb13-5"></a>odd &lt;-<span class="st"> </span>coro<span class="op">::</span><span class="kw">generator</span>(<span class="cf">function</span>(n) {</span>
<span id="cb13-6"><a href="#cb13-6"></a>  <span class="cf">if</span> (n <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) <span class="kw">trm_return</span>(<span class="ot">FALSE</span>) <span class="cf">else</span> <span class="kw">yield</span>(<span class="kw">even</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>))</span>
<span id="cb13-7"><a href="#cb13-7"></a>})</span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="kw">trampoline</span>(<span class="kw">even</span>(<span class="dv">10000</span>))</span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="kw">trampoline</span>(<span class="kw">even</span>(<span class="dv">10001</span>))</span>
<span id="cb13-12"><a href="#cb13-12"></a><span class="co">#&gt; [1] FALSE</span></span>
<span id="cb13-13"><a href="#cb13-13"></a></span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="kw">trampoline</span>(<span class="kw">odd</span>(<span class="dv">10000</span>))</span>
<span id="cb13-15"><a href="#cb13-15"></a><span class="co">#&gt; [1] FALSE</span></span>
<span id="cb13-16"><a href="#cb13-16"></a><span class="kw">trampoline</span>(<span class="kw">odd</span>(<span class="dv">10001</span>))</span>
<span id="cb13-17"><a href="#cb13-17"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>Note that the above only works if you specify the function directly as generators. This is because the <code>odd()</code> function won’t be converted to a generator by <code>trampoline()</code> because it doesn’t ‘know’ about it. You can get around this by passing the <code>odd()</code> function in as a named argument like this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a>even &lt;-<span class="st"> </span><span class="cf">function</span>(n) {</span>
<span id="cb14-2"><a href="#cb14-2"></a>  <span class="cf">if</span> (n <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) <span class="kw">trm_return</span>(<span class="ot">TRUE</span>) <span class="cf">else</span> <span class="kw">yield</span>(<span class="kw">odd</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>))</span>
<span id="cb14-3"><a href="#cb14-3"></a>}</span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a>odd &lt;-<span class="st"> </span><span class="cf">function</span>(n) {</span>
<span id="cb14-6"><a href="#cb14-6"></a>  <span class="cf">if</span> (n <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) <span class="kw">trm_return</span>(<span class="ot">FALSE</span>) <span class="cf">else</span> <span class="kw">yield</span>(<span class="kw">even</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>))</span>
<span id="cb14-7"><a href="#cb14-7"></a>}</span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="co">## doesn&#39;t work</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="kw">trampoline</span>(<span class="kw">even</span>(<span class="dv">10000</span>))</span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="co">#&gt; Error in yield(even(n - 1)): could not find function &quot;yield&quot;</span></span>
<span id="cb14-12"><a href="#cb14-12"></a></span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="co">## does work</span></span>
<span id="cb14-14"><a href="#cb14-14"></a><span class="kw">trampoline</span>(<span class="kw">even</span>(<span class="dv">10000</span>), <span class="dt">odd =</span> odd)</span>
<span id="cb14-15"><a href="#cb14-15"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>An example where <code>trampoline</code> can really shine is in branching recursive functions, such as functions that traverse trees of various kinds, where we don’t want to worry about hitting the call stack limit with large trees. One natural way of specifying these generally cannot be converted to tail call form easily because the recursive function is called multiple times within its body, and so they cannot all be in tail position. For some examples of these more complicated branching recursive functions, see the vignette “Traversing Trees with Trampoline”.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
